#include "../include/game.hpp"

#include "xil_printf.h"

Game::Game() : 
    //Player1(Point2d((MIN_X + MAX_X)/2 - (PLAYER_WIDTH / 2), FLOOR_HEIGHT + PLAYER_HEIGHT), Point2d(0, 0), Point2d(0, ACCELERATION)),
	Player1(Point2d((MIN_X + MAX_X)/2 ,0), Point2d(0, 0), Point2d(0, ACCELERATION)),
    gameTime(0.0f),
	floorCounter(5),
	floorsPosition(0),
	sidesPosition(0),
    isStarted(false),
	gameOver(false),
	PlayerLocked(true),
	PlayerLockFloor(0)
{

    this->floors[0] = Line2d( Point2d(MIN_X,INITIAL_HEIGHT), Point2d(MAX_X, INITIAL_HEIGHT) );

    for(int i = 1; i < N_FLOORS; i++){
    	this->floors[i] = Line2d::RandomLine(200, 600, MIN_X, MAX_X, FLOOR_SPACING * i + INITIAL_HEIGHT);
    }

    this->PlayerLocked = true;
    this->PlayerLockFloor = 0;
}

void Game::Display(){

}

#include "xparameters.h"
#define KEY_SPACE (1 << 0)
#define KEY_LEFT (1 << 2)
#define KEY_RIGHT (1 << 4)
#define KEYBOARD_BASE		XPAR_KEYBOARDCONTROLLER_0_S00_AXI_BASEADDR
#define KEYBOARD_KEYS		(*(uint32_t*)(KEYBOARD_BASE + 0))

void Game::Run(){

	if(KEYBOARD_KEYS & KEY_LEFT){
		this->Player1.changePosition(Point2d(-10, 0));
	}

	if(KEYBOARD_KEYS & KEY_RIGHT){
			this->Player1.changePosition(Point2d(10, 0));
	}

	if(!this->isStarted){
		if(KEYBOARD_KEYS & KEY_SPACE){
		//	this->Player1.changePosition(Point2d(0, 5));
			this->isStarted = 1;
		}

		if(this->PlayerLocked){
			this->Player1.setPosition( Point2d( this->Player1.getPosition().GetX(), this->floors[this->PlayerLockFloor].GetStart().GetY() ) );
			this->Player1.setVelocity( Point2d(0, -1/0.01) );
		}
	}

	if(this->isStarted){

		if(this->PlayerLocked){

			if( this->Player1.getPosition().GetX() < this->floors[this->PlayerLockFloor].GetStart().GetX());
			if( this->Player1.getPosition().GetX() > this->floors[this->PlayerLockFloor].GetEnd().GetX());

			this->Player1.setPosition( Point2d( this->Player1.getPosition().GetX(), this->floors[this->PlayerLockFloor].GetStart().GetY() ) );
			this->Player1.setVelocity( Point2d(0, -1/0.01) );

			if(KEYBOARD_KEYS & KEY_SPACE){
				this->PlayerLocked = false;
	//			this->Player1.changePosition(Point2d(0, 20));
				this->Player1.setVelocity( Point2d(0, 300) );
			}
		}
		else {
			Point2d p1 = Player1.getPosition();
			this->Player1.calculateNextPosition(0.05);
			Point2d p2 = Player1.getPosition();
			Line2d PlayerMove(p2, p1);

			if(this->Player1.getVelocity().GetY() < 0){
				Point2d solution;
				float collision_distance = 1337.0f;
				for(int i = 0; i < N_FLOORS ; i++){
					if ( this->floors[i].CheckIntersection( PlayerMove, solution ) ){
						float distance = abs(solution.GetY() - p1.GetY());
						if(distance < collision_distance){
							collision_distance = distance;
							this->PlayerLockFloor = i;
							this->PlayerLocked = true;
						};
						xil_printf("intersection, %d\r\n", i);
					}
				}
			}
		}

		if(this->Player1.getPosition().GetY() < PLAYER_MIN_Y){
			this->Player1.setPosition( Point2d( this->Player1.getPosition().GetX(), PLAYER_MIN_Y ) );
			this->Player1.setVelocity( this->Player1.getVelocity() * Point2d(1, 0) );
			this->gameOver = true;
		}

		if(this->gameOver){
			this->isStarted = false;
		}


		int moveRate = 0;
		if(this->Player1.getPosition().GetY() > PLAYER_MAX_Y){
			moveRate = this->Player1.getPosition().GetY() - PLAYER_MAX_Y;
			this->Player1.setPosition( Point2d( this->Player1.getPosition().GetX(), PLAYER_MAX_Y) );
		}

		for(int i = 0; i < N_FLOORS; i++){
			if(this->floorCounter % 100){
				if (this->floors[i].moveDown(moveRate,-FLOOR_HEIGHT,MAX_Y, false) ) this->floorCounter++;
			}
			else{
				if (this->floors[i].moveDown(moveRate,-FLOOR_HEIGHT,MAX_Y, true) ) this->floorCounter++;
			}
		}


		if(this->PlayerLocked){
			if (this->floors[this->PlayerLockFloor].GetStart().GetY() < -FLOOR_HEIGHT + 1){
				this->PlayerLocked = false;
			}
		}

		this->floorsPosition -= moveRate;
		this->sidesPosition = this->floorsPosition / 2;
	}

}

Line2d Game::GetFloor(int FloorIndex){return this->floors[FloorIndex];};
texture_t Game::GetFloorTexture(int FloorIndex){return this->floorTexture[FloorIndex];};
Player Game::GetPlayer(){return this->Player1;};
float Game::GetFloorsPosition(){return this->floorsPosition;};
float Game::GetSidesPosition(){return this->sidesPosition;};

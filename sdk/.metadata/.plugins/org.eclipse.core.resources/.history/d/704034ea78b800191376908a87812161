#include "../include/line2d.hpp"
#include "../include/point2d.hpp"
#include "../include/player.hpp"
#include "xstatus.h"
#include "xaxidma.h"
#include "xparameters.h"
#include "xintc.h"
#include "xil_exception.h"

#include "../include/textures.h"

#include "../include/utils.h"

#include <algorithm>

#define VGA_BASE 	XPAR_BLOCKS_S00_AXI_BASEADDR
#define VGA_XPOS 	(*(uint16_t*)(VGA_BASE + 0))
#define VGA_YPOS 	(*(uint16_t*)(VGA_BASE + 2))
#define VGA_WIDTH 	(*(uint16_t*)(VGA_BASE + 4))
#define VGA_HEIGHT 	(*(uint16_t*)(VGA_BASE + 6))
#define VGA_XSCALE 	(*(uint16_t*)(VGA_BASE + 8))
#define VGA_YSCALE 	(*(uint16_t*)(VGA_BASE + 10))

#define PLAYER_BASE 	XPAR_PLAYER_S00_AXI_BASEADDR
#define PLAYER_XPOS 	(*(uint16_t*)(PLAYER_BASE + 0))
#define PLAYER_YPOS 	(*(uint16_t*)(PLAYER_BASE + 2))
#define PLAYER_WIDTH 	(*(uint16_t*)(PLAYER_BASE + 4))
#define PLAYER_HEIGHT 	(*(uint16_t*)(PLAYER_BASE + 6))
#define PLAYER_XSCALE 	(*(uint16_t*)(PLAYER_BASE + 8))
#define PLAYER_YSCALE 	(*(uint16_t*)(PLAYER_BASE + 10))

static inline u16 rgb565torgb444(u16 rgb565){
	return ( ((rgb565 & 0x1e) >> 1) | ((rgb565 & 0x780) >> 3)  | ((rgb565 & 0xf000) >> 4) );
}

XAxiDma dma;
XAxiDma_Config *dma_config;

XAxiDma dma1;
XAxiDma_Config *dma_config1;

Line2d Lines[6];
Player P1(Point2d(500,500), Point2d(0,0), Point2d(0,-100));

XIntc InterruptController;
#define INTC_DEVICE_ID		  XPAR_INTC_0_DEVICE_ID
#define INTC_DEVICE_INT_ID	  XPAR_INTC_0_VGA_BLOCK_0_VEC_ID

int it_counter = 0;
int block_counter = 0;

void DeviceDriverHandler(void *CallbackRef)
{
	static int i = 5;

	it_counter++;

	XAxiDma_SimpleTransfer(&dma, (UINTPTR)texture_memory[TEXTURE_REDSTONE].pixel_data, 16*16*2, XAXIDMA_DMA_TO_DEVICE);

	if(--i < 0){
		 i = 5;
	}

	VGA_XPOS = Lines[i].GetStart().GetX();
	VGA_WIDTH = Lines[i].GetEnd().GetX() - Lines[i].GetStart().GetX();

	VGA_HEIGHT = 64;
	int y = 1024 - 64 - (int)Lines[i].GetStart().GetY();
	if(y < 0){
		y = 1023 + VGA_HEIGHT + y;
	}
	VGA_YPOS = y;
}

void interrupt_init(XIntc *InterruptController, void(*callback)(void*), u16 interrupt_device_id, u8 interrupt_vector ){

	if (!InterruptController->IsReady) XIntc_Initialize(InterruptController,  interrupt_device_id);
	XIntc_Connect(InterruptController, interrupt_vector, (XInterruptHandler)callback, (void *)0);
	if (!InterruptController->IsStarted) XIntc_Start(InterruptController, XIN_REAL_MODE);
	XIntc_Enable(InterruptController, interrupt_vector);

	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XIntc_InterruptHandler, InterruptController);
	Xil_ExceptionEnable();
}


int main(){

    xil_printf("dupxo\r\n");

	VGA_XPOS = 1;
	VGA_YPOS = 1;
	VGA_XSCALE = 2;
	VGA_YSCALE = 2;
	VGA_WIDTH = 1;
	VGA_HEIGHT = 1;

	PLAYER_XPOS = P1.getPosition().GetX();
	PLAYER_YPOS = P1.getPosition().GetY() -  128;
	PLAYER_XSCALE = 2;
	PLAYER_YSCALE = 2;
	PLAYER_WIDTH = 64;
	PLAYER_HEIGHT = 64;

	dma_config = XAxiDma_LookupConfig(XPAR_AXIDMA_0_DEVICE_ID);
	XAxiDma_CfgInitialize(&dma, dma_config);

	dma_config1 = XAxiDma_LookupConfig(XPAR_AXIDMA_1_DEVICE_ID);
	XAxiDma_CfgInitialize(&dma1, dma_config1);

	GIMP_IMAGE_RUN_LENGTH_DECODE((unsigned char*)imagexd, gimp_image.rle_pixel_data, gimp_image.height * gimp_image.width, gimp_image.bytes_per_pixel);
	for (int i = 0; i < 16*16; i++){
		imagexd[i] = rgb565torgb444(imagexd[i]);
	}

	//GIMP_IMAGE_RUN_LENGTH_DECODE((unsigned char*)imagexd1, gimp_image1.rle_pixel_data, gimp_image1.height * gimp_image1.width, gimp_image1.bytes_per_pixel);
	uint16_t *pXD = (uint16_t*)gimp_image1.pixel_data;
	for (int i = 0; i < 16*16; i++){

		pXD[i] = rgb565torgb444(pXD[i]);
	}

	XAxiDma_SimpleTransfer(&dma, (UINTPTR)pXD, 16*16*2, XAXIDMA_DMA_TO_DEVICE);
	while( XAxiDma_Busy(&dma, XAXIDMA_DMA_TO_DEVICE) );

	XAxiDma_SimpleTransfer(&dma1, (UINTPTR)gimp_image1.pixel_data, 16*16*2, XAXIDMA_DMA_TO_DEVICE);
	while( XAxiDma_Busy(&dma1, XAXIDMA_DMA_TO_DEVICE) );

    interrupt_init(&InterruptController, DeviceDriverHandler, INTC_DEVICE_ID, INTC_DEVICE_INT_ID);

	Lines[0] = Line2d( Point2d(127, 63), Point2d(1151, 63) );
	for(int j = 1; j < 6; j++) Lines[j] = Line2d::RandomLine(200, 600, 127, 1151, 180 * j + 64);

    while(1){

    	int i = 0;
    	while(i++ < 100000);

		for(int j = 0; j < 6; j++){
			if (Lines[j].moveDown(10,-64,1023) ) block_counter++;
		}

//		for(int j = 0; j < 6; j++){
//			Lines[j].moveDown(2,-64,1023);
//			xil_printf("%d\t", (int)Lines[j].GetEnd().GetY());
//		}
//		xil_printf("\r\n");

		Point2d x = P1.getPosition();
		P1.calculateNextPosition(0.1);
		if(x.GetY() < -64){
			P1.setVelocity( P1.getVelocity() * Point2d(1, -0.f) );
			P1.setPosition( Point2d( P1.getPosition().GetX(), -64 ) );
		}
		Point2d y = P1.getPosition();
		PLAYER_YPOS = 1024 - 64 - P1.getPosition().GetY() - 64;
		xil_printf("%d\r\n", PLAYER_YPOS);

		Line2d PlayerMove(x, y);

		Point2d solution;
		for (int q = 0; q < 6; q++) {
			if (PlayerMove.CheckIntersection(Lines[q], solution)){
				xil_printf("intersection : line %d\r\n", q);
			}
		}
    }
}

#include "../include/game.hpp"
#include "../include/fpga_interface.h"

Game::Game(char * buf) :
	KeyUp(0),
	KeyDown(0),
	KeyEsc(0),
	KeyEnter(0),
	LastKeyUp(0),
	LastKeyDown(0),
	LastKeyEsc(0),
	LastKeyEnter(0),
	Player1(Point2d((MIN_X + MAX_X)/2 ,0), Point2d(0, 0), Point2d(0, ACCELERATION)),
	GameMenu(buf),
	MenuPosition(0),
	gameOver(false),
    gameTime(0.0f),
	CurrentState(Menu::State::STARTED),
	CurrentLevel(0),
	playerFloor(0),
	floorCounter(5),
	floorsPosition(0),
    ScrollFast(false),
	PlayerLocked(true),
	PlayerLockFloor(0),
	CurrentStage(0)
{

    floors[0] = Floor( Line2d(Point2d(MIN_X,INITIAL_HEIGHT), Point2d(MAX_X, INITIAL_HEIGHT)), (texture_t)CurrentStage );

    for(int i = 1; i < N_FLOORS; i++){
    	//TODO
    	floors[i] = Floor( Line2d::RandomLine(200, 600, MIN_X, MAX_X, FLOOR_SPACING * i + INITIAL_HEIGHT), (texture_t)CurrentStage);
    }

    for(int i = 0; i < N_FLOORS; i++){
    	relativeFloorNumber[i] = i;
    }

    PlayerLocked = true;
    PlayerLockFloor = 0;
}

void Game::Reset(){

	Player1.setPosition(Point2d((MIN_X + MAX_X)/2 ,0));
	Player1.setVelocity(Point2d(0, 0));
	Player1.setAcceleration(Point2d(0, ACCELERATION));
	gameTime = 0.0f;
	playerFloor = 0;
	floorCounter = 5;
	floorsPosition = 0;
	ScrollFast = false;
    PlayerLocked = true;
    PlayerLockFloor = 0;
    gameOver = false;
    CurrentState = Menu::State::GAME;
    CurrentStage = 0;

    floors[0] = Floor( Line2d(Point2d(MIN_X,INITIAL_HEIGHT), Point2d(MAX_X, INITIAL_HEIGHT)), (texture_t)CurrentStage );

    for(int i = 1; i < N_FLOORS; i++){
    	// TODO
    	floors[i] = Floor( Line2d::RandomLine(200, 600, MIN_X, MAX_X, FLOOR_SPACING * i + INITIAL_HEIGHT), (texture_t)CurrentStage);
    }

    for(int i = 0; i < N_FLOORS; i++){
    	relativeFloorNumber[i] = i;
    }

    PlayerLocked = true;
    PlayerLockFloor = 0;
}

void Game::Display(){

}

void Game::chceckCollisionsAndLock(int moveRate) {

	Line2d PlayerMove;
	Point2d p1 = Player1.getPosition();
	Player1.calculateNextPosition(DELTA_T);
	Point2d p2 = Player1.getPosition();
	PlayerMove = Line2d(p2, p1);

	if(Player1.getVelocity().GetY() < 0){

		Point2d solution;
		float collision_distance = 10000.0f;
		for(int i = 0; i < N_FLOORS ; i++){
			if ( floors[i].CheckIntersection( PlayerMove, solution ) ){
				float distance = abs(solution.GetY() - PlayerMove.GetEnd().GetY());
				if(distance < collision_distance){
					collision_distance = distance;
					PlayerLockFloor = i;
					PlayerLocked = true;
					if(playerFloor < relativeFloorNumber[i]) playerFloor = relativeFloorNumber[i];
				}
			}
		}
	}

	if(PlayerLocked){
		Player1.setPosition( Point2d( Player1.getPosition().GetX(), floors[PlayerLockFloor].GetStart().GetY() ) );
		Player1.setVelocity( Point2d( Player1.getVelocity().GetX(), -moveRate/DELTA_T) );
	}
}

void Game::moveFloors(int moveRate){

	if(ScrollFast){
		for(int i = 0; i < N_FLOORS; i++){

			float prevY = floors[i].GetStart().GetY();

			floors[i].moveDown(moveRate);

			//TODO tutaj funkcje ktore zwracaja minimalna i maksymalna dlugosc
			int minLength = 300;
			int maxLength = 400;

			int diff = MIN_Y - floors[i].GetStart().GetY();

			if(diff > 0){
				if (!(floorCounter++ % NEXT_STAGE)){
					CurrentStage++;
					if(CurrentStage > MAX_STAGES - 1) CurrentStage = random(unsigned int, MAX_STAGES);
					floors[i] = Floor( Line2d::RandomLine(SCREEN_WIDTH, SCREEN_WIDTH, MIN_X, MAX_X, MAX_Y - diff), (texture_t)CurrentStage );
				}
				else {
					floors[i] = Floor( Line2d::RandomLine(minLength, maxLength, MIN_X, MAX_X, MAX_Y - diff), (texture_t)CurrentStage );
				}
				floorCounter++;
				relativeFloorNumber[i] += N_FLOORS;
			}

// TODO jak zadziala to wyzej to usunac
//			if(floorCounter % 30){
//				if (floors[i].moveDown(moveRate,-FLOOR_HEIGHT,MAX_Y, false) ) {
//					floorCounter++;
//					relativeFloorNumber[i] += N_FLOORS;
//				}
//			}
//			else{
//				if (floors[i].moveDown(moveRate,-FLOOR_HEIGHT,MAX_Y, true) ) {
//					floorCounter++;
//					relativeFloorNumber[i] += N_FLOORS;
//				}
//			}

			float currentY = floors[i].GetStart().GetY();
			if((currentY > prevY) && i == PlayerLockFloor){
				PlayerLocked = false;
			}
		}
		floorsPosition += moveRate;
	}
}

#include "xparameters.h"
#define KEY_SPACE (1 << 0)
#define KEY_ENTER (1 << 1)
#define KEY_LEFT (1 << 2)
#define KEY_DOWN (1 << 3)
#define KEY_RIGHT (1 << 4)
#define KEY_UP (1 << 5)
#define KEY_ESC (1 << 6)
#define KEYBOARD_BASE		XPAR_KEYBOARDCONTROLLER_0_S00_AXI_BASEADDR
#define KEYBOARD_KEYS		(*(uint32_t*)(KEYBOARD_BASE + 0))
//TODO
void Game::Run(){
	GameMenu.SetState(CurrentState);
	switch(CurrentState){
		case Menu::State::STARTED:
		case Menu::State::FAILED:
			StateMenu();
			break;
		case Menu::State::GAME:
			StateGame();
			break;
		case Menu::State::PAUSED:
			StatePaused();
			break;
	}
	GameMenu.Draw();
	GameMenu.SetPosition(MenuPosition);
}

void Game::StatePaused(){
	KeyUp = KEYBOARD_KEYS & KEY_UP;
	KeyDown = KEYBOARD_KEYS & KEY_DOWN;
	KeyEsc = KEYBOARD_KEYS & KEY_ESC;
	if(KeyUp && (!LastKeyUp)){
		if(MenuPosition < 1) MenuPosition++;
		else MenuPosition = 0;
	}

	if(KeyDown && (!LastKeyDown)){
		if(MenuPosition != 0) MenuPosition--;
		else MenuPosition = 1;
	}

	if(KeyEsc && (!LastKeyEsc)){
		CurrentState = Menu::State::GAME;
	}

	if(KEYBOARD_KEYS & KEY_ENTER){
		switch(MenuPosition){
			case 0:
				CurrentState = Menu::State::GAME;
				break;
			case 1:
				CurrentState = Menu::State::STARTED;
				break;
			default:
				break;
		}
	}
	LastKeyUp = KeyUp;
	LastKeyDown = KeyDown;
	LastKeyEsc = KeyEsc;

}

void Game::StateMenu(){
	KeyUp = KEYBOARD_KEYS & KEY_UP;
	KeyDown = KEYBOARD_KEYS & KEY_DOWN;
	KeyEnter = KEYBOARD_KEYS & KEY_ENTER;
	if(KeyUp && (!LastKeyUp)){
		if(MenuPosition < 1) MenuPosition++;
		else MenuPosition = 0;
	}

	if(KeyDown && (!LastKeyDown)){
		if(MenuPosition != 0) MenuPosition--;
		else MenuPosition = 1;
	}

	if(KeyEnter && (!LastKeyEnter)){
		switch(MenuPosition){
			case 0:
				Reset();
				CurrentState = Menu::State::GAME;
				break;
			case 1:
				CurrentLevel++;
				CurrentLevel %= N_LEVELS;
				GameMenu.SetLevel(CurrentLevel);
				break;
			default:
				break;
		}
	}
	LastKeyUp = KeyUp;
	LastKeyDown = KeyDown;
	LastKeyEnter = KeyEnter;
}

void Game::StateGame(){

	if(KEYBOARD_KEYS & KEY_LEFT){
		Player1.changeVelocity(Point2d(-12, 0));
	}

	KeyEsc = KEYBOARD_KEYS & KEY_ESC;
	if(KeyEsc && (!LastKeyEsc)){
		CurrentState = Menu::State::PAUSED;
	}
	LastKeyEsc = KeyEsc;

	if(KEYBOARD_KEYS & KEY_RIGHT){
		Player1.changeVelocity(Point2d(12, 0));
	}

	if( (KEYBOARD_KEYS & KEY_SPACE) && PlayerLocked ){
		PlayerLocked = false;
		Player1.setVelocity( Point2d(Player1.getVelocity().GetX(), 300 + abs(Player1.getVelocity().GetX()) ) );
	}

	// TODO funkcja zwracajaca predkosc przesuwania
	moveFloors(1);
	chceckCollisionsAndLock(1);

	GameMenu.SetCounter(playerFloor);

	if (PlayerLocked) {
		if( Player1.getPosition().GetX() < floors[PlayerLockFloor].GetStart().GetX()) PlayerLocked = false;
		if( Player1.getPosition().GetX() > floors[PlayerLockFloor].GetEnd().GetX()) PlayerLocked = false;
		if (floors[PlayerLockFloor].GetStart().GetY() < -FLOOR_HEIGHT + 1) PlayerLocked = false;
	}

	if(Player1.getPosition().GetY() < PLAYER_MIN_Y){
		Player1.setPosition( Point2d( Player1.getPosition().GetX(), PLAYER_MIN_Y ) );
		gameOver = true;
		CurrentState = Menu::State::FAILED;
	}

//	//TODO do usuniecia jak zadziala
//	if(gameOver){
//		ScrollFast = false;
//	}

	if(Player1.getPosition().GetY() > SCROLL_HEIGHT) ScrollFast = 1;

	if(Player1.getPosition().GetY() > PLAYER_MAX_Y){
		moveFloors(Player1.getPosition().GetY() - PLAYER_MAX_Y);
		floorsPosition += Player1.getPosition().GetY() - PLAYER_MAX_Y;
		Player1.setPosition( Point2d( Player1.getPosition().GetX(), PLAYER_MAX_Y) );
	}

	if( Player1.getPosition().GetX() > (MAX_X - PLAYER_WIDTH / 2) ){
		Player1.setPosition( Point2d(MAX_X - PLAYER_WIDTH / 2, Player1.getPosition().GetY()) );
		Player1.setVelocity( Player1.getVelocity() * Point2d(-0.8f, 1.0f) );
	}

	if( Player1.getPosition().GetX() < (MIN_X + PLAYER_WIDTH / 2) ){
		Player1.setPosition( Point2d(MIN_X + PLAYER_WIDTH / 2, Player1.getPosition().GetY()) );
		Player1.setVelocity( Player1.getVelocity() * Point2d(-0.8f, 1.0f) );
	}

	if(PlayerLocked){
		Player1.setVelocity( Point2d(Player1.getVelocity().GetX() * FLOOR_FRICTION, Player1.getVelocity().GetY()) );
	}
	else {
		Player1.setVelocity( Point2d(Player1.getVelocity().GetX() * AIR_FRICTION, Player1.getVelocity().GetY()) );
	}

	if( abs(Player1.getVelocity().GetX()) < 0.001 ) Player1.setVelocity( Point2d(0, Player1.getVelocity().GetY()) );
}

Floor Game::GetFloor(int FloorIndex){return floors[FloorIndex];};
texture_t Game::GetFloorTexture(int FloorIndex){return floors[FloorIndex].GetTexture();};
Player Game::GetPlayer(){return Player1;};
float Game::GetFloorsPosition(){return floorsPosition;};
int Game::GetFloorCount(){return floorCounter;};
int Game::GetPlayerFloor(){return playerFloor;};
unsigned int Game::GetXPos(){return GameMenu.GetXPos();};
unsigned int Game::GetYPos(){return GameMenu.GetYPos();};
unsigned int Game::GetColor(){return GameMenu.GetColor();};
unsigned int Game::GetScale(){return GameMenu.GetScale();};
